<!doctype html>
<html lang="hr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Upload or Load running-config</title>
<style>
  :root {
    --blue: #233499;
    --blue-light: #aeb3d1;
    --border: #dce3ec;
    --text: #1f2937;
    --muted: #6b7280;
    --bg: #f9fafb;
    --card: #ffffff;
  }
  * {
    box-sizing: border-box;
  }

  body {
    font-family: "Arial";
    background: var(--bg);
    color: var(--text);
    margin: 0;
    padding: 2rem 1rem;
  }

  .container {
    max-width: 1100px;
    margin: 0 auto;
  }

  h1 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 1.5rem;
    color: var(--blue);
  }

  h2 {
    font-size: 1.1rem;
    margin: 0 0 0.75rem 0;
    font-weight: 600;
  }

  h3 {
    font-size: 0.95rem;
    margin: 1rem 0 0.5rem;
    font-weight: 600;
    color: var(--blue);
  }

  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
  }

  .toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
  }

  input[type="file"],
  select {
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 0.45rem 0.6rem;
    background: #fff;
    font-size: 0.9rem;
  }

  button {
    border: 1px solid var(--blue);
    background: var(--blue);
    color: #fff;
    border-radius: 6px;
    padding: 0.45rem 0.75rem;
    font-size: 0.9rem;
    cursor: pointer;
  }

  button.secondary {
    background: #fff;
    color: var(--blue);
  }

  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }

  pre {
    background: #0f172a;
    color: #e5e7eb;
    border-radius: 6px;
    padding: 0.75rem;
    font-size: 0.8rem;
    max-height: 320px;
    overflow: auto;
  }

  .summary {
    font-size: 0.85rem;
    color: var(--muted);
    margin-bottom: 0.5rem;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
    margin-top: 0.5rem;
  }

  th {
    background: var(--blue-light);
    text-align: left;
    font-weight: 600;
  }

  th,
  td {
    border: 1px solid var(--border);
    padding: 6px 8px;
    vertical-align: top;
  }
</style>


</head>
<body>
  <h1>Network device config parser with Neo4j</h1>

  <div>
    <input id="fileInput" type="file" accept=".txt,.cfg" />
    <button id="uploadBtn">Upload file to Neo4j</button>
    <button id="clearBtn">Clear</button>
  </div>

  <div style="margin-top:1rem;">
    <label for="deviceSelect"><strong>Load from Neo4j:</strong></label>
    <select id="deviceSelect"><option value="">— load list —</option></select>
    <button id="refreshDevicesBtn">Refresh list</button>
    <button id="loadFromDbBtn">Load selected</button>
  </div>
<button id="openSearchBtn">Search Neo4j</button>

  <div class="grid" style="margin-top:1rem;">
    <div>
      <h2>Raw config</h2>
      <pre id="rawConfig">Config file not loaded</pre>
    </div>
    <div>
      <h2>Parsed summary</h2>
      <div id="summary">Not available.</div>
    </div>
  </div>

<div id="searchPanel" style="display:none; margin-top:1rem;">
  <h2>Search Database</h2>
  <button id="backSearchBtn">← Back</button>

  <div style="margin-top:1rem;">
    <h3>Search by VLAN ID</h3>
    <input id="vlanInput" type="number" placeholder="Enter VLAN ID" />
    <button id="searchVlanBtn">Search VLAN</button>
  </div>

<div style="margin-top:1rem;">
  <h3>Search by Port Mode</h3>
  <select id="portModeSelect">
    <option value="">— select —</option>
    <option value="trunk">trunk</option>
    <option value="access">access</option>
  </select>
  <button id="searchPortModeBtn">Search Ports</button>
</div>

<div style="margin-top:1.5rem;">
  <h3>Custom Cypher query</h3>
  <textarea id="cypherInput" rows="5" style="width:100%;"
    placeholder="Your cypher query here"></textarea>
  <button id="runCypherBtn">Execute</button>
</div>


  <div style="margin-top:1rem;">
    <h3>Show Physical Topology</h3>
    <button id="showTopologyBtn">Show Topology</button>
  </div>

  <div id="searchResults" style="margin-top:1rem;"></div>
</div>

  <h2>Details</h2>
  <div id="details"></div>

  <script>
    const fileInput = document.getElementById('fileInput');
    const rawConfigEl = document.getElementById('rawConfig');
    const summaryEl = document.getElementById('summary');
    const detailsEl = document.getElementById('details');
    const uploadBtn = document.getElementById('uploadBtn');
    const clearBtn = document.getElementById('clearBtn');
    const deviceSelect = document.getElementById('deviceSelect');
    const refreshDevicesBtn = document.getElementById('refreshDevicesBtn');
    const loadFromDbBtn = document.getElementById('loadFromDbBtn');

    let currentText = '';

    fileInput.addEventListener('change', async (e) => {
      const f = e.target.files[0];
      if (!f) return;
      currentText = await f.text();
      rawConfigEl.textContent = currentText;
      summaryEl.textContent = 'Parsed, ready to upload.';
      detailsEl.innerHTML = '';
      renderPreview(parseConfigClient(currentText));
    });

    uploadBtn.addEventListener('click', async () => {
      if (!currentText) return alert('Choose a file.');
      uploadBtn.disabled = true;
      try {
        const res = await fetch('/api/upload-config', {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain' },
          body: currentText
        });
        if (!res.ok) throw new Error('Upload failed');
        const json = await res.json();
        renderPreview(json);
        alert('Configuration saved to Neo4j database');
        await refreshDevices();
      } catch (err) {
        console.error(err);
        alert('Error: ' + err.message);
      } finally {
        uploadBtn.disabled = false;
      }
    });

    clearBtn.addEventListener('click', () => {
      currentText = '';
      rawConfigEl.textContent = 'Not loaded.';
      summaryEl.textContent = 'Not available.';
      detailsEl.innerHTML = '';
      fileInput.value = '';
    });

    refreshDevicesBtn.addEventListener('click', refreshDevices);
    loadFromDbBtn.addEventListener('click', async () => {
      const name = deviceSelect.value;
      if (!name) return alert('Choose device from list');
      try {
        const res = await fetch('/api/device/' + encodeURIComponent(name));
        if (!res.ok) throw new Error('Fetch failed');
        const json = await res.json();
        rawConfigEl.textContent = '(loaded from DB)';
        renderPreview(json);
      } catch (err) {
        console.error(err);
        alert('Error when fetching from DB: ' + err.message);
      }
    });

    async function refreshDevices() {
      deviceSelect.innerHTML = '<option value="">— učitavam —</option>';
      try {
        const res = await fetch('/api/devices');
        if (!res.ok) throw new Error('Failed');
        const list = await res.json();
        deviceSelect.innerHTML = '<option value="">— choose from available devices —</option>';
        list.forEach(h => {
          const opt = document.createElement('option');
          opt.value = h;
          opt.textContent = h;
          deviceSelect.appendChild(opt);
        });
      } catch (err) {
        console.error(err);
        deviceSelect.innerHTML = '<option value="">— Error —</option>';
        alert('Error when loading device list');
      }
    }

    refreshDevices();

function renderPreview(data) {
  if (!data) return;
  summaryEl.innerHTML = `<strong>Device:</strong> ${data.hostname || '—'} — <strong>Interfaces:</strong> ${data.interfaces?.length || 0} — <strong>VLANs:</strong> ${data.vlans?.length || 0} — <strong>DHCP Pools:</strong> ${data.dhcpPools?.length || 0}`;

  const parts = [];

  if (data.hostname) parts.push(`<h3>Hostname</h3><p>${data.hostname}</p>`);
  if (data.password) parts.push(`<h3>Password</h3><p>${data.password}</p>`);
  
      if (data.interfaces?.length) {
        let rows = '<tr><th>Name</th><th>IP</th><th>Mode</th><th>Description</th></tr>';
        data.interfaces.forEach(i => {
          rows += `<tr><td>${i.name}</td><td>${i.ip||''}</td><td>${i.mode||''}</td><td>${i.description||''}</td>`;
        });
        parts.push(`<h3>Interfaces</h3><table>${rows}</table>`);
      }

      if (data.vlans?.length) {
        let rows = '<tr><th>VLAN</th><th>Comment</th></tr>';
        data.vlans.forEach(v => rows += `<tr><td>${v.id}</td><td>${v.name||''}</td>`);
        parts.push(`<h3>VLANs</h3><table>${rows}</table>`);
      }

      if (data.dhcpPools?.length) {
        let rows = '<tr><th>Name</th><th>Network</th><th>Default-router</th></tr>';
        data.dhcpPools.forEach(p => rows += `<tr><td>${p.name}</td><td>${p.network||''}</td><td>${p.defaultRouter||''}</td>`);
        parts.push(`<h3>DHCP Pools</h3><table>${rows}</table>`);
      }

if (data.accessLists?.length) {
  let rows = '<tr><th>Name/Number</th><th>Rules</th></tr>';
  data.accessLists.forEach(a => {
    
    const cleanedRules = a.rules.map(r => {
    const m = r.match(/\b(permit|deny|remark|sequence)\b/i);
  return m ? r.slice(m.index) : r;
});
rows += `<tr><td>${a.name}</td><td><pre>${cleanedRules.join('\n')}</pre></td></tr>`;
  });
  parts.push(`<h3>Access-lists</h3><table>${rows}</table>`);
}
      detailsEl.innerHTML = parts.join('');
    }

function parseConfigClient(text) {
  const lines = text.split(/\r?\n/);
  const data = { hostname: null, interfaces: [], vlans: [], dhcpPools: [], accessLists: [] };
  let curBlock = null;

  for (let raw of lines) {
    const line = raw.trim();
    if (!line) continue;

    if (line.startsWith('hostname ')) {
      data.hostname = line.split(/\s+/)[1];
      continue;
    }

    const intMatch = line.match(/^interface\s+(.+)/);
    if (intMatch) {
      curBlock = { type: 'interface', name: intMatch[1], lines: [] };
      data.interfaces.push(curBlock);
      continue;
    }

    const vlanMatch = line.match(/^vlan\s+(\d+)/);
    if (vlanMatch) {
      curBlock = { type: 'vlan', id: vlanMatch[1], lines: [] };
      data.vlans.push(curBlock);
      continue;
    }

    const ipDhcpPool = line.match(/^ip dhcp pool\s+(.+)/);
    if (ipDhcpPool) {
      curBlock = { type: 'dhcp', name: ipDhcpPool[1], lines: [] };
      data.dhcpPools.push(curBlock);
      continue;
    }

    const aclMatch = line.match(/^access-list\s+(\d+|\w+)/);
    if (aclMatch) {
      const name = aclMatch[1];
      let entry = data.accessLists.find(a => a.name === name);
      if (!entry) {
        entry = { name, rules: [] };
        data.accessLists.push(entry);
      }
      entry.rules.push(line);
      curBlock = null;
      continue;
    }

    if (curBlock) {
      curBlock.lines.push(line);
    }
    }
    
    const exists = data.interfaces.find(i => i.name === name);
    if (!exists) {
      data.interfaces.push({ type: 'interface', name: name, lines: [`description (added from vlan ${vlanId} ${mode})`] });
    } else {
      if (!exists.lines.some(l => l.includes(`vlan ${vlanId} ${mode}`))) {
        exists.lines.push(`vlan ${vlanId} ${mode}`);
      }
    }
  }

  data.vlans.forEach(v => {
    v.lines.forEach(l => {
      const m = l.match(/^(tagged|untagged)\s+(.+)/i);
      if (!m) return;
      const mode = m[1].toLowerCase();         
    const listStr = m[2].trim();
      const parts = listStr.split(',').map(s => s.trim()).filter(Boolean);

      parts.forEach(part => {
  
        const normalized = part.replace(/\s*-\s*/g, '-');
        if (normalized.includes('-')) {
          const [startStr, endStr] = normalized.split('-');
          const start = parseInt(startStr, 10);
          const end = parseInt(endStr, 10);
          if (!Number.isNaN(start) && !Number.isNaN(end) && end >= start) {
            for (let n = start; n <= end; n++) {
              addSyntheticInterface(`interface ${n}`, v.id, mode);
            }
          }
        } else {
          const n = parseInt(normalized, 10);
          if (!Number.isNaN(n)) {
            addSyntheticInterface(`interface ${n}`, v.id, mode);
          }
        }
      });
    });
  });

  data.interfaces = data.interfaces.map(b => {
    const obj = { name: b.name };
    (b.lines || []).forEach(l => {
      const ip = l.match(/^ip address\s+(\S+)\s+(\S+)/);
      if (ip) obj.ip = ip[1] + ' ' + ip[2];
      const desc = l.match(/^description\s+(.+)/);
      if (desc) obj.description = desc[1];
      if (l.includes('switchport mode')) obj.mode = l.split('switchport mode')[1].trim();
      const dot1q = l.match(/encapsulation dot1Q\s+(\d+)/i);
      if (dot1q) obj.dot1q = dot1q[1];
      if (l.includes('ip nat inside')) obj.nat = 'inside';
      if (l.includes('ip nat outside')) obj.nat = 'outside';
      const vlanAnnot = l.match(/^vlan\s+(\d+)\s+(tagged|untagged)/i);
      if (vlanAnnot) {
        if (!obj.vlans) obj.vlans = [];
        obj.vlans.push({ id: vlanAnnot[1], mode: vlanAnnot[2].toLowerCase() });
      }
    });
    return obj;
  });

  data.vlans = data.vlans.map(b => {
    const obj = { id: b.id };
    b.lines.forEach(l => {
      const name = l.match(/^ name\s+(.+)/i);
      if (name) obj.name = name[1];
    });
    return obj;
  });

  data.dhcpPools = data.dhcpPools.map(b => {
    const obj = { name: b.name };
    b.lines.forEach(l => {
      const net = l.match(/^network\s+(\S+)\s+(\S+)/);
      if (net) obj.network = net[1] + ' ' + net[2];
      const dr = l.match(/^default-router\s+(.+)/);
      if (dr) obj.defaultRouter = dr[1].trim();
    });
    return obj;
  });

  return data;
}


///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

      
const openSearchBtn = document.getElementById('openSearchBtn');
const searchPanel = document.getElementById('searchPanel');
const backSearchBtn = document.getElementById('backSearchBtn');
const vlanInput = document.getElementById('vlanInput');
const searchVlanBtn = document.getElementById('searchVlanBtn');
const natSelect = document.getElementById('natSelect');
const searchNatBtn = document.getElementById('searchNatBtn');
const showTopologyBtn = document.getElementById('showTopologyBtn');
const searchResults = document.getElementById('searchResults');
const cypherInput = document.getElementById('cypherInput');
const runCypherBtn = document.getElementById('runCypherBtn');

runCypherBtn.addEventListener('click', async () => {
  const query = cypherInput.value.trim();
  if (!query) {
    alert('Unesi Cypher upit');
    return;
  }

  try {
    const res = await fetch('/api/search/cypher', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query })
    });

    if (!res.ok) {
      const err = await res.text();
      throw new Error(err || 'Cypher error');
    }

    const data = await res.json();
    renderSearchResults(data, 'Custom query result');
  } catch (err) {
    alert('Greška: ' + err.message);
  }
});

openSearchBtn.addEventListener('click', () => {
  searchPanel.style.display = 'block';
  detailsEl.innerHTML = '';
});

backSearchBtn.addEventListener('click', () => {
  searchPanel.style.display = 'none';
  searchResults.innerHTML = '';
});

searchVlanBtn.addEventListener('click', async () => {
  const vlanId = vlanInput.value.trim();
  if (!vlanId) return alert('Enter VLAN ID');
  try {
    const res = await fetch('/api/search/vlan?vlan=' + encodeURIComponent(vlanId));
    if (!res.ok) throw new Error('Search failed');
    const json = await res.json();
    renderSearchResults(json, `Devices in VLAN ${vlanId}`);
  } catch (err) {
    alert('Error: ' + err.message);
  }
});


const portModeSelect   = document.getElementById('portModeSelect');
const searchPortModeBtn = document.getElementById('searchPortModeBtn');

searchPortModeBtn.addEventListener('click', async () => {
  const mode = portModeSelect.value; 
  if (!mode) {
    alert('Select port mode (trunk or access)');
    return;
  }

  try {
    const response = await fetch(
      '/api/search/port-mode?mode=' + encodeURIComponent(mode)
    );

    if (!response.ok) {
      const errText = await response.text().catch(() => null);
      throw new Error(errText || 'Search failed');
    }

    const data = await response.json();

    renderSearchResults(data, `Interfaces with mode: ${mode}`);
  } catch (err) {
    alert('Error: ' + err.message);
  }
});


showTopologyBtn.addEventListener('click', async () => {
  try {
    const res = await fetch('/api/search/topology');
    if (!res.ok) throw new Error('Search failed');
    const json = await res.json();
    renderSearchResults(json, 'Physical Topology');
  } catch (err) {
    alert('Error: ' + err.message);
  }
});

function renderSearchResults(data, title) {
  let html = `<h3>${title}</h3>`;
  if (!Array.isArray(data) || data.length === 0) {
    html += '<p>No results</p>';
  } else {
    html += '<table><tr>';
    Object.keys(data[0]).forEach(k => html += `<th>${k}</th>`);
    html += '</tr>';

    data.forEach(row => {
      html += '<tr>';
      Object.values(row).forEach(v => html += `<td>${v}</td>`);
      html += '</tr>';
    });
    html += '</table>';
  }
  searchResults.innerHTML = html;
}
//////////////////////////////////////////////////////////////////////////
  </script>
</body>
</html>

